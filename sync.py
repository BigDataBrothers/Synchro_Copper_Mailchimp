#!/usr/bin/env python3
"""
Version finale du script avec synchronisation des tags vers Mailchimp
"""

import os
import requests
import hashlib
import traceback
from dotenv import load_dotenv
from datetime import datetime
import json
import time

load_dotenv()

# Configuration du logging
log_filename = f"sync_log_{datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}.txt"
log_file = open(log_filename, "w", encoding='utf-8')

class Colors:
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    BLUE = '\033[94m'
    END = '\033[0m'

def log(message, level="INFO"):
    timestamp = datetime.now().strftime('%H:%M:%S')
    color = {"INFO": Colors.BLUE, "SUCCESS": Colors.GREEN, "WARNING": Colors.YELLOW, "ERROR": Colors.RED}.get(level, "")
    icon = {"INFO": "‚ÑπÔ∏è", "SUCCESS": "‚úÖ", "WARNING": "‚ö†Ô∏è", "ERROR": "‚ùå"}.get(level, "üìù")
    
    console_message = f"{color}[{timestamp}] {icon} {message}{Colors.END}"
    file_message = f"[{timestamp}] {icon} {message}"
    
    print(console_message)
    log_file.write(file_message + "\n")
    log_file.flush()

# Configuration APIs
COPPER_API_URL = os.getenv("COPPER_API_URL", "https://api.copper.com/developer_api/v1")
COPPER_API_EMAIL = os.getenv("COPPER_API_EMAIL")
COPPER_API_KEY = os.getenv("COPPER_API_KEY")

MC_API_KEY = os.getenv("MAILCHIMP_API_KEY")
MC_DC = os.getenv("MAILCHIMP_DC")
MC_LIST_ID = os.getenv("MAILCHIMP_LIST_ID")
MC_BASE = f"https://{MC_DC}.api.mailchimp.com/3.0"
MC_AUTH = ("anystring", MC_API_KEY)

COPPER_HEADERS = {
    "X-PW-AccessToken": COPPER_API_KEY,
    "X-PW-Application": "developer_api",
    "X-PW-UserEmail": COPPER_API_EMAIL,
    "Content-Type": "application/json"
}

def is_delete_tag_robust(tag):
    """D√©tection robuste du tag de suppression"""
    if not tag or not isinstance(tag, str):
        return False
    
    normalized = str(tag).strip().upper()
    normalized = normalized.replace('√Ä', 'A').replace('√Å', 'A').replace('√Ç', 'A')
    normalized = normalized.replace('√à', 'E').replace('√â', '√â').replace('√ä', 'E')
    
    conditions = [
        "SUPPRIMER" in normalized,
        "üóë" in normalized,
        "DELETE" in normalized,
        "REMOVE" in normalized,
        "A SUPPRIMER" in normalized
    ]
    
    return any(conditions)

def is_inactive_tag(tag):
    """D√©tection du tag inactif"""
    if not tag or not isinstance(tag, str):
        return False
    
    normalized = str(tag).strip().upper()
    normalized = normalized.replace('√Ä', 'A').replace('√Å', 'A').replace('√Ç', 'A')
    normalized = normalized.replace('√à', 'E').replace('√â', '√â').replace('√ä', 'E')
    
    conditions = [
        "INACTIF" in normalized,
        "üì•" in normalized,
        "INACTIVE" in normalized,
        "ARCHIVED" in normalized
    ]
    
    return any(conditions)

def normalize_email(email):
    """Normalise un email"""
    return email.lower().strip()

def is_target_email(email):
    """V√©rifie si l'email est dans le scope de test"""
    return "@exemple" in email.lower()

def get_subscriber_hash(email):
    """G√©n√®re le hash subscriber pour Mailchimp"""
    return hashlib.md5(email.lower().encode()).hexdigest()

def safe_request(func, *args, **kwargs):
    """Wrapper pour les requ√™tes avec retry"""
    max_retries = 2
    retry_delay = 0.5
    
    for attempt in range(max_retries):
        try:
            response = func(*args, **kwargs)
            response.raise_for_status()
            return response
        except requests.exceptions.RequestException as e:
            if attempt == max_retries - 1:
                log(f"√âchec d√©finitif apr√®s {max_retries} tentatives: {e}", "ERROR")
                raise
            log(f"Tentative {attempt + 1} √©chou√©e: {e}. Retry dans {retry_delay}s", "WARNING")
            time.sleep(retry_delay)

def get_target_copper_contacts():
    """R√©cup√®re seulement les contacts Copper avec emails @exemple (optimis√©)"""
    log("üîÑ R√©cup√©ration des contacts Copper cibles (@exemple)...", "INFO")
    contacts = []
    page = 1
    
    while True:
        url = f"{COPPER_API_URL}/people/search"
        payload = {"page_number": page, "page_size": 200}
        
        response = safe_request(requests.post, url, headers=COPPER_HEADERS, json=payload)
        data = response.json()
        
        if not data:
            break
        
        # Filtrer imm√©diatement les contacts avec @exemple
        target_contacts = []
        for contact in data:
            emails = contact.get("emails", [])
            if emails and is_target_email(emails[0]["email"]):
                target_contacts.append(contact)
        
        contacts.extend(target_contacts)
        log(f"   Page {page}: +{len(target_contacts)} contacts cibles (Total: {len(contacts)})", "INFO")
        
        if len(data) < 200:
            break
            
        page += 1
    
    log(f"‚úÖ {len(contacts)} contacts Copper cibles r√©cup√©r√©s", "SUCCESS")
    return contacts

def sync_contact_to_mailchimp(contact, tags_to_sync=None):
    """Synchronise un contact vers Mailchimp avec ses tags (optimis√©)"""
    emails = contact.get("emails", [])
    if not emails:
        return False
    
    email = emails[0]["email"]
    
    # Emails d√©j√† filtr√©s en amont, pas besoin de re-v√©rifier
    first_name = contact.get("first_name", "")
    last_name = contact.get("last_name", "")
    
    # Pr√©parer les tags pour Mailchimp
    mailchimp_tags = []
    if tags_to_sync:
        for tag in tags_to_sync:
            # Nettoyer les tags pour Mailchimp (max 50 caract√®res)
            clean_tag = str(tag)[:50]
            mailchimp_tags.append({"name": clean_tag, "status": "active"})
    
    # Donn√©es pour Mailchimp
    mailchimp_data = {
        "email_address": email,
        "status_if_new": "subscribed",
        "merge_fields": {
            "FNAME": first_name,
            "LNAME": last_name
        }
    }
    
    try:
        subscriber_hash = get_subscriber_hash(email)
        url = f"{MC_BASE}/lists/{MC_LIST_ID}/members/{subscriber_hash}"
        
        # Synchroniser le contact
        response = safe_request(requests.put, url, auth=MC_AUTH, json=mailchimp_data)
        
        # Synchroniser les tags si fournis
        if mailchimp_tags:
            tags_url = f"{MC_BASE}/lists/{MC_LIST_ID}/members/{subscriber_hash}/tags"
            tags_payload = {"tags": mailchimp_tags}
            
            tag_response = safe_request(requests.post, tags_url, auth=MC_AUTH, json=tags_payload)
            log(f"‚úÖ Synchronis√© avec tags: {email} ({len(mailchimp_tags)} tags)", "SUCCESS")
        else:
            log(f"‚úÖ Synchronis√©: {email}", "SUCCESS")
        
        return True
        
    except Exception as e:
        log(f"‚ùå Erreur sync {email}: {e}", "ERROR")
        return False

def handle_marked_contacts(marked_contacts):
    """G√®re les contacts marqu√©s pour suppression"""
    if not marked_contacts:
        log("‚úÖ Aucun contact marqu√© pour suppression", "SUCCESS")
        return
    
    log(f"‚ö†Ô∏è {len(marked_contacts)} contact(s) marqu√©(s) pour suppression d√©tect√©(s)", "WARNING")
    
    # Affichage des contacts
    for i, contact in enumerate(marked_contacts, 1):
        log(f"   {i}. {contact['email']} - {contact['name']} (Tag: '{contact['detected_tag']}')", "INFO")
    
    choice = input("\nü§î Que voulez-vous faire ? (t=traiter un par un, g=traiter en groupe, i=ignorer): ").lower()
    
    if choice == "i":
        log("‚ÑπÔ∏è Contacts ignor√©s pour cette session", "INFO")
    elif choice == "g":
        action = input("Action pour tous (a=archiver, s=supprimer): ").lower()
        if action == "a":
            log("üîÑ Archivage en cours...", "INFO")
            for contact in marked_contacts:
                archive_contact(contact)
        elif action == "s":
            log("üîÑ Suppression en cours...", "INFO")
            for contact in marked_contacts:
                delete_contact(contact)
    elif choice == "t":
        for contact in marked_contacts:
            print(f"\nüìß Contact: {contact['email']} - {contact['name']}")
            action = input("Action (a=archiver, s=supprimer, i=ignorer): ").lower()
            if action == "a":
                archive_contact(contact)
            elif action == "s":
                delete_contact(contact)

def archive_contact(contact):
    """Archive un contact (statut Inactif dans Copper + d√©sabonnement Mailchimp)"""
    try:
        email = contact["email"]
        copper_id = contact["copper_id"]
        
        # 1. Marquer comme inactif dans Copper (ajout d'un tag)
        copper_url = f"{COPPER_API_URL}/people/{copper_id}"
        
        # R√©cup√©rer le contact actuel pour conserver ses tags existants
        response = safe_request(requests.get, copper_url, headers=COPPER_HEADERS)
        current_contact = response.json()
        
        # Ajouter le tag "üì• INACTIF" aux tags existants
        existing_tags = current_contact.get("tags", [])
        if "üì• INACTIF" not in existing_tags:
            existing_tags.append("üì• INACTIF")
        
        # Supprimer le tag de suppression et ajouter le tag inactif
        existing_tags = [tag for tag in existing_tags if not is_delete_tag_robust(str(tag))]
        existing_tags.append("üì• INACTIF")
        
        # Mettre √† jour le contact dans Copper
        update_payload = {"tags": existing_tags}
        response = safe_request(requests.put, copper_url, headers=COPPER_HEADERS, json=update_payload)
        
        # 2. D√©sabonner de Mailchimp
        subscriber_hash = get_subscriber_hash(email)
        mc_url = f"{MC_BASE}/lists/{MC_LIST_ID}/members/{subscriber_hash}"
        
        response = safe_request(requests.patch, mc_url, auth=MC_AUTH, 
                              json={"status": "unsubscribed"})
        
        log(f"‚úÖ Contact {email} archiv√© (Inactif dans Copper + d√©sabonn√© Mailchimp)", "SUCCESS")
    except Exception as e:
        log(f"‚ùå Erreur archivage {contact['email']}: {e}", "ERROR")

def delete_contact(contact):
    """Supprime un contact (Copper + Mailchimp)"""
    try:
        email = contact["email"]
        
        # Supprimer de Mailchimp
        subscriber_hash = get_subscriber_hash(email)
        url = f"{MC_BASE}/lists/{MC_LIST_ID}/members/{subscriber_hash}"
        response = safe_request(requests.delete, url, auth=MC_AUTH)
        
        # Supprimer de Copper
        copper_url = f"{COPPER_API_URL}/people/{contact['copper_id']}"
        response = safe_request(requests.delete, copper_url, headers=COPPER_HEADERS)
        
        log(f"‚úÖ Contact {email} supprim√© (Copper + Mailchimp)", "SUCCESS")
    except Exception as e:
        log(f"‚ùå Erreur suppression {contact['email']}: {e}", "ERROR")

def get_target_mailchimp_contacts():
    """R√©cup√®re seulement les contacts Mailchimp avec emails @exemple (optimis√©)"""
    log("üîÑ R√©cup√©ration des contacts Mailchimp cibles (@exemple)...", "INFO")
    members = []
    offset = 0
    count = 1000
    
    while True:
        url = f"{MC_BASE}/lists/{MC_LIST_ID}/members"
        params = {
            "offset": offset,
            "count": count,
            "status": "subscribed"
        }
        
        response = safe_request(requests.get, url, auth=MC_AUTH, params=params)
        data = response.json()
        
        batch = data.get("members", [])
        if not batch:
            break
        
        # Filtrer imm√©diatement les contacts avec @exemple
        target_members = []
        for member in batch:
            email = member.get("email_address", "")
            if is_target_email(email):
                target_members.append(member)
        
        members.extend(target_members)
        log(f"   Offset {offset}: +{len(target_members)} membres cibles (Total: {len(members)})", "INFO")
        
        if len(batch) < count:
            break
            
        offset += count
    
    log(f"‚úÖ {len(members)} membres Mailchimp cibles r√©cup√©r√©s", "SUCCESS")
    return members

def sync_mailchimp_to_copper(mc_members, copper_contacts_by_email):
    """Synchronise Mailchimp vers Copper (optimis√©)"""
    synced_count = 0
    
    for member in mc_members:
        email = normalize_email(member.get("email_address", ""))
        
        # V√©rifier si le contact existe d√©j√† dans Copper
        if email in copper_contacts_by_email:
            continue  # Contact d√©j√† pr√©sent
            
        # Cr√©er le contact dans Copper
        first_name = member.get("merge_fields", {}).get("FNAME", "")
        last_name = member.get("merge_fields", {}).get("LNAME", "")
        
        if not first_name and not last_name:
            continue  # Skip si pas de nom
            
        contact_data = {
            "name": f"{first_name} {last_name}".strip(),
            "emails": [{"email": email, "category": "work"}],
            "first_name": first_name,
            "last_name": last_name
        }
        
        try:
            url = f"{COPPER_API_URL}/people"
            response = safe_request(requests.post, url, headers=COPPER_HEADERS, json=contact_data)
            
            log(f"‚úÖ Nouveau contact cr√©√© dans Copper: {email}", "SUCCESS")
            synced_count += 1
            
        except Exception as e:
            log(f"‚ùå Erreur cr√©ation {email} dans Copper: {e}", "ERROR")
    
    return synced_count

def main():
    """Fonction principale avec synchronisation des tags"""
    start_time = time.time()
    
    log("üöÄ SYNCHRONISATION BIDIRECTIONNELLE COPPER ‚Üî MAILCHIMP", "INFO")
    log("=" * 60, "INFO")
    
    try:
        # 1. R√©cup√©ration optimis√©e des contacts cibles uniquement
        log("üéØ R√âCUP√âRATION OPTIMIS√âE (emails @exemple uniquement)", "INFO")
        copper_contacts = get_target_copper_contacts()
        mailchimp_members = get_target_mailchimp_contacts()
        
        # 2. Construction des index optimis√©s
        log("üîß Construction des index email...", "INFO")
        copper_by_email = {}
        mc_by_email = {}
        
        for contact in copper_contacts:
            emails = contact.get("emails", [])
            if emails:
                email = normalize_email(emails[0]["email"])
                copper_by_email[email] = contact
        
        for member in mailchimp_members:
            email = normalize_email(member.get("email_address", ""))
            mc_by_email[email] = member
        
        log(f"‚úÖ Index cr√©√©s: {len(copper_by_email)} contacts Copper cibles, {len(mc_by_email)} membres Mailchimp cibles", "SUCCESS")
        
        # V√©rification s'il y a des contacts √† traiter
        if len(copper_by_email) == 0 and len(mc_by_email) == 0:
            log(f"‚ÑπÔ∏è Aucun contact cible trouv√© (@exemple) - rien √† synchroniser", "INFO")
            execution_time = time.time() - start_time
            log(f"‚úÖ SYNCHRONISATION TERMIN√âE en {execution_time:.2f}s (aucun contact √† traiter)", "SUCCESS")
            return
        
        # 3. Analyse et traitement des contacts Copper
        marked_contacts = []
        copper_to_mc_synced = 0
        excluded_contacts = 0
        
        log("üîÑ Analyse et synchronisation Copper ‚Üí Mailchimp...", "INFO")
        
        for contact in copper_contacts:
            tags = contact.get("tags", [])
            
            # V√©rifier si marqu√© pour suppression
            is_marked = False
            is_inactive = False
            detected_tag = None
            
            for tag_name in tags:
                if is_delete_tag_robust(str(tag_name)):
                    is_marked = True
                    detected_tag = tag_name
                    break
                elif is_inactive_tag(str(tag_name)):
                    is_inactive = True
                    break
            
            if is_marked:
                # Contact marqu√© pour suppression
                emails = contact.get("emails", [])
                if emails:
                    marked_contacts.append({
                        "email": emails[0]["email"],
                        "name": f"{contact.get('first_name', '')} {contact.get('last_name', '')}".strip(),
                        "copper_id": contact.get("id"),
                        "detected_tag": detected_tag
                    })
                excluded_contacts += 1
            elif is_inactive:
                # Contact inactif - exclure de la synchronisation
                excluded_contacts += 1
            else:
                # Contact normal - synchroniser avec tags
                if sync_contact_to_mailchimp(contact, tags):
                    copper_to_mc_synced += 1
        
        # 4. Synchronisation Mailchimp ‚Üí Copper (optimis√©e)
        log("üîÑ Synchronisation Mailchimp ‚Üí Copper...", "INFO")
        mc_to_copper_synced = sync_mailchimp_to_copper(mailchimp_members, copper_by_email)
        
        # 5. R√©sultats d√©taill√©s
        total_synced = copper_to_mc_synced + mc_to_copper_synced
        log(f"üìä R√©sultats de la synchronisation bidirectionnelle:", "INFO")
        log(f"   Contacts Copper ‚Üí Mailchimp: {copper_to_mc_synced}", "INFO")
        log(f"   Contacts Mailchimp ‚Üí Copper: {mc_to_copper_synced}", "INFO")
        log(f"   Total synchronis√©: {total_synced}", "INFO")
        log(f"   Contacts exclus (inactifs): {excluded_contacts}", "INFO")
        log(f"   Contacts marqu√©s pour suppression: {len(marked_contacts)}", "INFO")
        
        if total_synced > 0:
            log(f"‚úÖ Synchronisation r√©ussie : {total_synced} contact(s) trait√©(s)", "SUCCESS")
        else:
            log(f"‚ÑπÔ∏è Aucune synchronisation n√©cessaire - tous les contacts sont √† jour", "INFO")
        
        # 6. Gestion des contacts marqu√©s
        handle_marked_contacts(marked_contacts)
        
        execution_time = time.time() - start_time
        log(f"‚úÖ SYNCHRONISATION BIDIRECTIONNELLE TERMIN√âE en {execution_time:.2f}s", "SUCCESS")
        
    except Exception as e:
        log(f"‚ùå ERREUR CRITIQUE: {e}", "ERROR")
        log(f"üîç Traceback: {traceback.format_exc()}", "ERROR")
    
    finally:
        log_file.close()

if __name__ == "__main__":
    main()
